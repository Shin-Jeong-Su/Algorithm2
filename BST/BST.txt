이진검색트리
#BST_1
완탐구성. 시간복잡도가 삼십만x삼십만 해서 십억을 넘어가므로 완탐으로 구현했으면 안됐음.

#BST_2
그리디풀이는 귀류법으로 내가 증명할 수 있어야 함. 수학적으로 하면 더 좋고.
귀류법이란 명제가 아니라면~인 것. 
예를 들어 가장 큰 보석을 가장 작은 가방에 넣어야 한다 라는 명제가있을때 귀류법으로 증명하게 위해 다음과 같은 명제를 세울 수 있음. 가장 큰 보석을 가장 작은 가방에 담지 않아야 하는지? 가장 작은 가방이 아니어야 하는지? 가장큰 보석이 아니어야 하는지? 와 같이 명제에서 not을 붙여 질문을 던져봐야 한다.
BST이용. c++의 multiset, set, map은 BST로 구현되어있음.
cf. unordered set, unordered mat, unordered multi set은 hash로 구성.
lower_bound(m)은 m이상 최소iterator을 찾는것. upper_bound(m)은 m을 초과하는 최소iterator을 찾는것
lower_bound와 upper_bound는 사용 전 오름차순으로 정렬해야 한다.
#BST_3
priority queue이용.

우선순위 큐란?
힙과 이진검색트리는 다름. 힙은 이진트리로 구성. 최대값 최소값을 찾기위해 힙을 사용할 수 있다. 부모가 자식보다 크면 최대힙 부모가 자식보다 작으면 최소힙이라고 한다.
우선순위 큐는 원소의 추가, 우선순위가 가장 높은 원소의 확인, 우선순위가 가장 높은 원소의 제거 이 3개의 기능을 제공합니다. 그리고 그냥 배열로 쉽게 구현하면 세 연산의 시간복잡도가 각각 O(1), O(N), O(N)이 되겠지만 힙이라는 이름의 구조를 이용하면 세 연산을 O(lg N), O(1), O(lg N)에 처리할 수 있습니다.
우선순위큐란 디폴트는 내림차순. 오름차순으로 하고싶으면 greater을 붙여야함.