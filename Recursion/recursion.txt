Recursion
재귀에서는 귀납적사고를 적용해야함. 
귀납적사고란? 1에서 2. 2에서 3으로 가는게 아니라 1에서 k. k에서 k+1이 그러므로 전체결과는 ~이다.

예를들면 f(k)가 1부터 k까지 출력하고 f(k+1)이 1부터 k+1까지 출력한다면 
종료조건이 있어야 하며 종료조건으로 재귀는 수렴해야한다.
함수의 인자로 어떤것을 받고 이 함수가 어디까지 계산하고 자기자신에게 넘겨줄지 명확하게 정의해야한다.
함수호출이 비용이 크기때문에 재귀를 반복문으로 구현할 수 있다면 반복이 나을 수 있다.

피보나치를 재귀로 구현하면
초기값 
int fibo(int n){
	if n<=1
		return 1;
	return (fibo(n-1)+fibo(n-2));
}
와 같이 구현할 수 있다. 하지만 이 코드의 문제점은 계산한걸 또 계산하기 떄문에 시간복잡도가 O(1.618^n)이라는 것이다.
따라서 이미 계산한 걸 다시 자기를 호출해서 계산하지 않도록 하는게 중요하다.

함수는 스택메모리에 쌓인다. 스택메모리는 비교적 사이즈가 작기 때문에

rcs1
백준1629 곱셈
a b c가 주어지고 a^b 를 c로 나눈 나머지를 구해야하는데 O(b)로 작성하니 시간초과가 뜬다.
여기서 사용되는 로직은 a^2n %c == _mod 이면 a^n%c=_mod*_mod 라는 것이다. 이것으로 문제를 분할하여 O(log2N)의 시간복잡도를 가질 수 있다.

rcs2
백준 11729 하노이
귀납적으로 생각할것. base condition일 때 잘 작동하고 k일때 잘 작동하면 k+1일때도 잘 작동한다.
n개를 3번에 옮기려면 일단 n-1개를 2번에 옮겨놓고 n번째를 3번에 놓은 후 다시 n-1개를 2번에서 3번으로 옮겨야 한다.
이 과정이 k일떄 k+1일때도 반복이다. 그리고 n이 1일때는 3으로 바로 옮기면 되니 재귀를 생각해볼 수 있다.
재귀를 작성할 떄 이것이 어떤 함수인지 정의하고 언떤 인자를 받을 것인지 생각해야한다.
from 과 to 둘 중 하나만 있으면 안되며 둘다 있어야 하고 몇개를 보낼 것인지도 있어야 한다. 2번에 옮길지 3번에 옮길지는 6-from-to관계에 있으므로 이것을 활용한다.

그리고 여기서 총 횟수를 물어보는데 k개를 옮길 때 A번의 이동이 필요하면 k+1개를 옮기려면 k개를 2번에 옮기는 과정 A번, k+1번째를 3번에 옮기는 과정 +1, k개를 다시 2번에서 3번으로
옮기는 과정 A번이 든다. 초항이 1이므로 일반항은 2^k-1이 된다.

rcs3
백준 1072 Z
함수 정의를 명확하게 해야함. 2^n x 2^n 배열에서 row와 col 인 번호를 반환하는 함수. 이렇게.
k번째와 k+1번째의 관계를 알아야함.