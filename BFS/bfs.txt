bfs유형
flood fill, 거리측정, 시작점 여러개, 시작점 두종류 등
bfs1
백준1926번 그림
맵이 주어지고 그림의 개수와 그림의 최대크기를 구해야함.
전체 맵을 순회하며 bfs를 각 적용함으로써 그림의 개수를 알 수 있고 
bfs내에서 반환값을 이용하여 얼마나 반복되는지 체크함으로써 그림의 최대크기를 알 수 있음.
bfs를 구현할 때 중요한 점은, 거의 정형화된 느낌이 있지만, 큐를 사용해서 너비를 넓혀가는 것이다.
맵이 주어진 문제는 pair을 사용하는게 편하다.
bfs함수 내부에서 함수를 재호출하는데 굳이 그럴필요는 없음. 그냥 지역변수를 누적합하면됨.

bfs2
백준2178 미로탐색
bfs함수내에서 bfs를 다시 호출하진 않음. q에 front와 연결된 것들을 넣고 그것들을 while문 안에서 순회하는 거니까 함수를 재호출할 필요도 없음.

bfs3
백준7576 토마토
시작이 정해지지 않은경우 어디서부터 시작할건지?
시작이정해지지 않은경우 모든경우를 체크하면서 완전탐색으로 돈다고 할 떄 시간복잡도를 생각해보자. nm만큼 돌면서 bfs도 nm만큼 호출하게 되니. n^2m^2만큼의 시간복잡도가 걸릴것이다.
시간복잡도가 좀 큰 것 같은데 그렇다면 어떤방법을 사용해야하는지? 
시작이 정해지지 않은경우 각 케이스를 안다면 그냥 그 케이스들을 모두 큐에넣고 bfs를 시작하면된다. 
그러면 겹치는 구간의 visted는 어떻게 되는건지? 이전의 값+1을 현재 visited에 넣어서 누적합을 구현하려고하는데 겹치는 구간이 문제가 생길것 같다.
하지만 깊이우선이 아니라 너비우선이기때문에 겹치는 구간은 누적합최소값으로 채워지게 된다. 따라서 문제가 되지 않는다.

bfs4
백준4179 불
최소값을 구하는 문제는 최대부터 시작한다. 예)1234567890부터 시작

변수가 A와 B 두개가 있고 서로 영향을 준다면 단순 bfs로만 풀 수는 없다. 백트래킹을 같이 사용해야한다.

이 문제를 불과 지훈이에 대해 각 너비우선탐색을 적용하고 각 누적합 배열을 비교하면서 최소값을 출력하도록 작성했다.
하지만 배열을 비교하고 최소값을 출력하는 과정에서 예외사항이 있었는데 그것은 다음과 같다.
각 케이스 모두 가장자리에서, 지훈이의 누적합이 0인경우또는 불의 누적합이 0인경우.
전자의 경우 지훈이와 불이 그곳을 방문하지 않았는데 최소값으로 인식되는 경우이고 후자의 경우 불이 방문하지 않았는데 지훈이는 방문할 수 있는 경우이다.

bfs4_1
가장자리를 비교하지말고 불에대한 bfs 다음에 지훈이에대한 bfs를 수행할 때 가장자리까지 도달하면 끝내는 경우도 있다.

bfs5
백준 1697번 숨박꼭질
dp로 풀수 있을까? 했는데 찾으러가는 놈의 시작점이 0이아니라서 시작점에 따라 값이 다 다르므로 dp를 사용하기 어렵다고 생각.
bfs를 사용하는데 나는 2*k의 범위를 벗어나면 루프를 다시 반복하게 작성했다. 하지만 이건 n이 k보다 클 떄를 간과한 것이라 이런 케이스의 경우 -1로 값이 고정되어 나온다.
해결방법은 저 케이스만 따로 처리하던가 범위를 2*k보다 클때가 아니라  100000 으로 애초에 k의 최대범위만큼 보다 클때로 잡아주면 된다.